# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12JbrX94SPhotD-PwEbog4kSfBqcIs7WG
"""

# mount drive
from google.colab import drive
drive.mount('/content/drive')

# pip install required packages
!pip install mne pandas matplotlib numpy

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import mne
from math import ceil

import zipfile
import os

zip_path = '/content/drive/MyDrive/EEG.machinelearing_data_BRMH.csv.zip'
extract_path = '/content/EEG_dataset'

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print("Files extracted to:", extract_path)
os.listdir(extract_path)
import pandas as pd

# Try to find CSV inside extracted folder
csv_files = [f for f in os.listdir(extract_path) if f.endswith('.csv')]
print("CSV files found:", csv_files)

data_path = os.path.join(extract_path, csv_files[0])
df = pd.read_csv(data_path)

print("Shape:", df.shape)
df.head()

# Identify columns that are completely empty (all NaN)
mis = df.isna().sum()
all_empty = mis[mis == df.shape[0]]
print("Fully-empty columns:", list(all_empty.index[:5]), " ... total:", len(all_empty))

# If there is at least one, assume the first such column is the separator (same logic as original)
if len(all_empty) > 0:
    sep_col = all_empty.index[0]

    start_col = 'main.disorder'
    df = df.loc[:, start_col:sep_col].drop(sep_col, axis=1)
    print("Trimmed df shape:", df.shape)
else:
    print("No fully-empty separator column found; skipping trimming.")

# Example preview of column names
cols_preview = df.columns.tolist()[:30]
cols_preview

def reformat_name(name):

    if '.' not in name:
        return name
    parts = name.split('.')

    bands = ['delta','theta','alpha','beta','gamma','lowalpha','highalpha']
    band = None
    chan = None
    for p in parts:
        p_lower = p.lower()
        if p_lower in bands:
            band = p_lower
    # assume channel is the last part that looks like an electrode (letters+digits)
    possible_chan = [p for p in parts[::-1] if any(c.isalpha() for c in p)]
    if len(possible_chan) > 0:
        chan = possible_chan[0]
    if band and chan:
        return f"{band}.{chan.upper()}"
    # fallback: return original
    return name

# Apply to columns except the metadata columns on the left (detect metadata by dtype or known names)
meta_cols = []
# try to detect first few metadata columns:
possible_meta = ['main.disorder','specific.disorder','patient','id','label']
for m in possible_meta:
    if m in df.columns:
        meta_cols.append(m)


if len(meta_cols) == 0:
    meta_cols = df.columns[:6].tolist()

print("Metadata columns detected:", meta_cols)

# Rename only the non-meta columns
data_cols = [c for c in df.columns if c not in meta_cols]
renamed = {c: reformat_name(c) for c in data_cols}
df = df.rename(columns=renamed)
print("Example renamed columns:", list(renamed.items())[:8])

# Show new columns preview
df.columns.tolist()[:30]

# Make metadata df and eeg features df
meta_cols = [c for c in df.columns if not ('.' in c)]  # heuristic: metadata columns don't contain a dot
meta_df = df[meta_cols].copy()
eeg_cols = [c for c in df.columns if '.' in c]
eeg_df = df[eeg_cols].copy()

print("Metadata columns:", meta_df.columns.tolist())
print("EEG feature columns count:", len(eeg_cols))
print("EEG df shape:", eeg_df.shape)
eeg_df.iloc[:3, :6]  # show small snippet

# Ensure columns are unique
assert len(set(eeg_df.columns)) == len(eeg_df.columns), "duplicate columns detected"

# Attach metadata back for grouping
full = pd.concat([meta_df.reset_index(drop=True), eeg_df.reset_index(drop=True)], axis=1)
print("Full df shape (meta + eeg):", full.shape)

"""fix

"""

# this to inspect the real column names and sample values
pd.set_option('display.max_rows', 200)
pd.set_option('display.max_colwidth', 200)

print("Full df shape (as currently in memory):", df.shape)
print("\nFirst 80 column names:")
print(df.columns.tolist()[:80])   # adjust slice if you want to see more

# Show dtypes and number of unique values for the first 60 columns
cols = df.columns.tolist()
meta_scan = pd.DataFrame({
    'col': cols[:60],
    'dtype': [df[c].dtype for c in cols[:60]],
    'n_unique': [df[c].nunique(dropna=False) for c in cols[:60]],
    'sample_values': [df[c].dropna().unique()[:5].tolist() for c in cols[:60]]
})
meta_scan

# Candidate keywords that suggest a metadata/disorder column
keywords = ['disorder', 'patient', 'id', 'group', 'label', 'diagnosis', 'main', 'specific']

# Heuristic detection:
meta_cols = []
for c in df.columns:
    # If column dtype is object and has low cardinality, it's likely metadata
    if df[c].dtype == 'object':
        nunique = df[c].nunique(dropna=False)
        # pick as metadata if unique count is much smaller than rows (e.g., < 0.2 * n_rows)
        if nunique < 0.2 * df.shape[0] or any(k in c.lower() for k in keywords):
            meta_cols.append(c)
    # numeric columns could still be metadata (like age) so check small unique numeric columns too
    else:
        nunique = df[c].nunique(dropna=False)
        if nunique < 10 and any(k in c.lower() for k in keywords):
            meta_cols.append(c)

# Fallback: if nothing found, try finding columns that contain the words in samples
if len(meta_cols) == 0:
    for c in df.columns:
        sample = df[c].astype(str).head(30).str.lower().tolist()
        if any(any(kw in s for kw in keywords) for s in sample):
            meta_cols.append(c)

# If still empty, fall back to the original first-6 heuristic (but warn)
if len(meta_cols) == 0:
    meta_cols = df.columns[:6].tolist()
    print("Warning: automatic meta detection failed — falling back to first 6 columns as metadata:", meta_cols)

print("Detected metadata columns (heuristic):", meta_cols)
print("Number of metadata cols:", len(meta_cols))

# Now treat the rest as EEG feature columns
eeg_cols = [c for c in df.columns if c not in meta_cols]
print("EEG feature column count (heuristic):", len(eeg_cols))

# Show the first few detected meta columns with their sample values
for c in meta_cols[:10]:
    print("\nColumn:", c)
    print(df[c].value_counts().head(10))

# Coerce eeg feature columns to numeric
non_numeric_cols = []
for c in eeg_cols:
    # try converting and count number of non-numeric entries
    converted = pd.to_numeric(df[c], errors='coerce')
    n_non_numeric = converted.isna().sum() - df[c].isna().sum()  # new NaNs introduced by coercion
    if n_non_numeric > 0:
        non_numeric_cols.append((c, int(n_non_numeric)))
    df[c] = converted

print("Columns that had non-numeric entries (col, #non-numeric introduced):")
print(non_numeric_cols[:10])
print("Total columns with coercion issues:", len(non_numeric_cols))

# If many non-numeric issues exist, print a small sample
if len(non_numeric_cols) > 0:
    print("\nSample problematic columns + head of values:")
    for c, cnt in non_numeric_cols[:5]:
        print("\nColumn:", c)
        print(df[c].head(8))

meta_df = df[meta_cols].copy()
eeg_df = df[eeg_cols].copy()

print("meta_df shape:", meta_df.shape)
print("eeg_df shape:", eeg_df.shape)
print("Example metadata columns:", meta_df.columns.tolist()[:10])
print("Example EEG columns:", eeg_df.columns.tolist()[:10])

# Choose correct column names for grouping (update if your metadata names differ)
# If the heuristic found something that looks like the disorder column, prefer that.
cand_main = [c for c in meta_cols if 'main' in c.lower() or 'main.disorder' in c.lower()]
cand_spec = [c for c in meta_cols if 'specific' in c.lower() or 'specific.disorder' in c.lower()]

# fallback: try to find by keywords in the values (most frequent string that contains 'disorder' etc.)
if len(cand_main) == 0:
    for c in meta_cols:
        vals = meta_df[c].astype(str).str.lower()
        if vals.str.contains('disorder').any() or vals.str.contains('control').any():
            cand_main.append(c)
if len(cand_spec) == 0:
    for c in meta_cols:
        vals = meta_df[c].astype(str).str.lower()
        if vals.str.contains('depress') or vals.str.contains('ptsd') or vals.str.contains('anxiety'):
            cand_spec.append(c)

# Final selection (or set manually if needed)
main_col = cand_main[0] if len(cand_main) > 0 else (meta_cols[0] if len(meta_cols)>0 else None)
specific_col = cand_spec[0] if len(cand_spec) > 0 else (meta_cols[1] if len(meta_cols)>1 else main_col)

print("Using main_col =", main_col)
print("Using specific_col =", specific_col)

# Now compute means — only numeric eeg_df columns
numeric_eeg_cols = eeg_df.select_dtypes(include=[np.number]).columns.tolist()
print("Number of numeric EEG columns:", len(numeric_eeg_cols))

main_mean = pd.concat([meta_df[main_col], eeg_df[numeric_eeg_cols]], axis=1).groupby(main_col).mean()
specific_mean = pd.concat([meta_df[specific_col], eeg_df[numeric_eeg_cols]], axis=1).groupby(specific_col).mean()

print("main_mean shape:", main_mean.shape)
print("specific_mean shape:", specific_mean.shape)

# Check for disorder columns
print("Columns in metadata:", meta_df.columns.tolist()[:10])

# The names used in original notebook:
main_col = 'main.disorder'      # <-- CHANGE if your column name differs
specific_col = 'specific.disorder'  # <-- CHANGE if your column name differs

# Verify existence
for c in [main_col, specific_col]:
    if c not in full.columns:
        raise ValueError(f"Column '{c}' not found in your data. Please update the variable names.")

# group means
main_mean = full.groupby(main_col)[eeg_cols].mean()
specific_mean = full.groupby(specific_col)[eeg_cols].mean()

print("main_mean shape:", main_mean.shape)
print("specific_mean shape:", specific_mean.shape)

"""visualization"""

import matplotlib.pyplot as plt
import numpy as np
import mne
from math import ceil

#  You can keep or adjust these if your channels differ
chs = {
    'FP1': [-0.03, 0.08], 'FP2': [0.03, 0.08],
    'F7': [-0.073, 0.047], 'F3': [-0.04, 0.041],
    'FZ': [0, 0.038], 'F4': [0.04, 0.041], 'F8': [0.073, 0.047],
    'T3': [-0.085, 0], 'C3': [-0.045, 0], 'CZ': [0, 0],
    'C4': [0.045, 0], 'T4': [0.085, 0], 'T5': [-0.073, -0.047],
    'P3': [-0.04, -0.041], 'PZ': [0, -0.038], 'P4': [0.04, -0.041],
    'T6': [0.07, -0.047], 'O1': [-0.03, -0.08], 'O2': [0.03, -0.08]
}

# Convert to 3D coordinates
for key in chs.keys():
    chs[key] += [0]

mont = mne.channels.make_dig_montage(chs)
fig = mont.plot(show_names=True)
plt.show()

# Get all band names and channel names from column labels like "alpha.F3"
bands = sorted(set([c.split('.')[0] for c in main_mean.columns]))
channels = sorted(set([c.split('.')[1].upper() for c in main_mean.columns]))

print("Detected EEG Bands:", bands)
print("Detected Channels:", channels)

print(main_mean.index.tolist())

def plot_eeg(levels, positions, ax, fig, ch_names=None,
             cmap='Spectral_r', vmin=None, vmax=None, marker=None):
    """
    Draw a simple topomap for EEG data values.
    levels : 1D array of values (one per channel)
    positions : dict of 3D coordinates (e.g., from 'chs')
    """
    coords = np.array(list(positions.values()))[:, :2]  # use only X,Y

    # Try using vmin/vmax if supported; otherwise, fallback gracefully
    try:
        im, _ = mne.viz.plot_topomap(
            levels, coords, axes=ax, show=False, cmap=cmap,
            vlim=(vmin, vmax) if vmin is not None else None
        )
    except TypeError:
        # For older/newer versions without vlim support
        im, _ = mne.viz.plot_topomap(
            levels, coords, axes=ax, show=False, cmap=cmap
        )

    ax.set_title(ch_names, fontsize=10)
    return im

example_disorder = 'Obsessive compulsive disorder'
example_band = 'alpha'

example_values = main_mean.loc[example_disorder, main_mean.columns.str.startswith(example_band)].to_numpy()

fig, ax = plt.subplots(figsize=(4,4))
plot_eeg(example_values, chs, ax, fig, ch_names=f"{example_disorder} – {example_band}")
plt.show()

# --- Step G: Create Multi-Topomap EEG Visualizations ---

def plot_eeg_dataset(df_mean, title, bands, disorders, ch_positions, save_path=None):
    """
    Plots multiple EEG topomaps for each disorder × frequency band
    """
    n_rows, n_cols = len(disorders), len(bands)
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(3*n_cols, 3*n_rows))
    fig.suptitle(title, fontsize=16)

    for i, disorder in enumerate(disorders):
        for j, band in enumerate(bands):
            values = df_mean.loc[disorder, df_mean.columns.str.startswith(band)].to_numpy()
            ax = axes[i, j] if n_rows > 1 else axes[j]
            plot_eeg(values, ch_positions, ax, fig, ch_names=f"{disorder} – {band}")

    plt.tight_layout(rect=[0, 0, 1, 0.96])
    if save_path:
        plt.savefig(save_path, dpi=300)
        print(f" Figure saved to: {save_path}")
    plt.show()


# Select disorders and frequency bands
selected_disorders = list(main_mean.index)
selected_bands = sorted(set([col.split('.')[0] for col in main_mean.columns]))

# Plot for main disorders
plot_eeg_dataset(main_mean,
                 "EEG Topomaps – Main Psychiatric Disorders",
                 selected_bands,
                 selected_disorders,
                 chs,
)

# Plot for specific disorders (optional)
selected_specific = list(specific_mean.index)
plot_eeg_dataset(specific_mean,
                 "EEG Topomaps – Specific Disorders",
                 selected_bands,
                 selected_specific,
                 chs,)